;   Include file for the USBSER PIC application.
;
;   This firmware is a USB to serial converter, using Embed's standard USB
;   driver on the host.
;
;   Peripheral usage:
;
;     Oscillator  -  Driven from 12 MHz external crystal.  With 4x PLL provides
;       the 48 MHz clock required for full speed USB operation.  The CPU runs
;       from this 48 MHz clock without being divided down.  The instruction rate
;       is therefore 12 MHz.
;
;     TMR2  -  Used as the main clock base in the INTR module, and sets the PWM
;       period as used in the SUPP module.  The timer configuration is
;       determined in this include file so that it is visible to all modules.
;       The timer is set up and managed in the INTR module.
;
;     UART  -  Provides the in-board interface to the USB enpoint 1 byte
;       streams.  Implements Embed USB device 10 protocol.  Managed in the UART
;       module.
;
;     USB  -  Managed in USB module.  Enumeration requests handled in USB0
;       module.
;
;     CCP1  -  Used in PWM mode to produce the pulses for driving the switching
;       power supply.  Only used when ISOLPWR set to TRUE.  Managed in the SUPP
;       module.
;
;     VREF  -  Supplies the reference to compare the power supply threshold
;       detect feedback signal to.  Only used when ISOLPWR is set to TRUE.
;       Managed in the SUPP module.
;
;     COMPARATOR 1  -  Compares the switching power supply feedback signal to
;       the VREF output.  This drives the PWM shutdown directly in hardware to
;       stop switching power supply pulses when the supply is above its
;       regulation threshold.  Only used when ISOLPWR is TRUE.  Managed in the
;       SUPP module.
;
/const   debug_icd bool = false
/const   debug   bool = false
/const   debug_0flood bool = false ;sends max rate 0 bytes to host when TP1 low
/const   debug_txie bool = false ;show TXIE state
/const   debug_main bool = false ;show on out pin when in main loop
;
;   Application configuration parameters
;
/const   namemaxlen integer = 80 ;max allowed char in user-settable name string
/const   cmd_ustat integer = 255 ;USB status command opcode to send to client

gbankadr equ     0           ;put ordinary globals into access bank
;
;   Identify the taget hardware.  BOARD can be one of the following strings:
;
;     S5MAIN2  -  The USB to serial converter built into the second Sentry 5
;       prototype, or later compatible.
;
;   Derive low level configuration details from the target board type.
;
/const   board   string = "S5MAIN2"
/pick one by board

/option "S5MAIN2"            ;Sentry 5 USB to CAN bridge, board ver 2
  /const usb_vid integer = 5824 ;USB vendor ID
  /const usb_pid integer = 1489 ;device ID within VID, Embed device 10
  /const usb_curr real = 0.050 ;USB power current draw, A
  /const usb_bufsz1 integer = 64 ;size of USB endpoint 1 buffers
  /const usb_manuf string = "Jowa USA" ;manufacturer name
  /const usb_prod string = "Sentry 5 USB to CAN bridge" ;product name
  /const usb_name = "Jowa Sentry 5" ;Embed10 device name
  /const tick_per = 0.001    ;base clock tick period, seconds
  /const baud real = 273438  ;desired UART baud rate
  /const txgo_in_pin string = "RB1" ;TXGO pin, allows UART sending when high

/optionelse                  ;BOARD didn't match a known board name
  /show "  Unsupported target board type " board " set in JDSP.INS.ASPIC"
         error   Board type
         end
  /stop
  /endpick

/include "usbserlib.ins.aspic"
;
;   Define the set or registers that will be saved across calls to TASK_YIELD.
;
tsksave  set     0           ;build the mask of registers for TASK_YIELD to save
tsksave  set     tsksave | regf0
tsksave  set     tsksave | regf1
tsksave  set     tsksave | regf2
tsksave  set     tsksave | regf3
tsksave  set     tsksave | regf4
tsksave  set     tsksave | regf5
tsksave  set     tsksave | regf6
tsksave  set     tsksave | regf7

/include "(cog)src/pic/task_setup.ins.aspic" ;derive additional tasking setup
;
;   Derived constants.
;
namemaxlen equ   [v namemaxlen]
         ;
         ;   Compute the timer 2 setup.  No code is generated, only the setup
         ;   parameters are derived from the desired clock tick period set by
         ;   TICK_PER, above.  The following preprocessor constants are set:
         ;
         ;     TMR2_PRE  -  timer 2 prescaler value: 1, 4, or 16
         ;
         ;     TMR2_PER  -  timer 2 period divide value: 1 - 256
         ;
         ;     TMR2_POS  -  timer 2 postscaler value: 1 - 16
         ;
         ;     TMR2_PERIOD  -  Actual timer 2 period in seconds.
         ;
         ;     TMR2_CYCLES  -  Actual timer 2 period in instruction cycles.
         ;
         ;     TMR2_PERPWM  -  Period for PWM (no postscaler) in seconds.
         ;
         ;     TMR2_CYPWM  -  Period for PWM in instruction cycles.
         ;
         ;     TMR2_FREQ  -  Actual timer 2 frequency, Hz.
         ;
         tmr2cy_closeper [v tick_per] ;compute timer setup

/include "usbser_usb.ins.aspic" ;global definitions required by USB subsystem

;**********
;
;   EEPROM allocation.  Each of the EE_xxx symbols is the offset of a particular
;   piece of non-volatile state from the beginning of the EEPROM.  Fixed
;   allocation of the EEPROM is performed here instead of letting the linker
;   place individual pieces of state so that consistancy is maintained between
;   firmware versions.  To the extent possible, newer firmware versions should
;   use the same EEPROM state in the same locations as previous versions.  This
;   at least makes it possible for non-volatile settings to be preserved for
;   some types of firmware updates, such as bootloads.  Note that this comment
;   does not guarantee any such mechanisms are actually implemented.
;
  cblock 0
         ee_namelen:1        ;number of characters in user-settable name string
         ee_name:namemaxlen  ;the user-settable name string characters
    endc

;**********
;
;   Global flag bits.
;
/flag    sin                 ;UART has a received character available
/flag    sout                ;UART can accept a new character to send
/flag    promlock            ;non-volatile memory is acquired by a task
/flag    uinbyte             ;a UART input byte is available in the FIFO
/flag    sendustat           ;send USTAT command to serial device

;*******************************************************************************
;
;   I/O pin declarations.
;

;***************************************
;
;   Define the I/O pins with fixed functions that can't be moved to other pins.
;
/outbit  pgc     portb 6     ;programming clock line
/outbit  pgd     portb 7     ;programming data line

/outbit  tx      portc 6 n   ;UART transmit line
/inbit   rx      portc 7     ;UART receive line

////////////////////////////////////////
//
//   Define all remaining I/O pins.  Unused pins are named with the pin name
//   (like RA1, RB5) and set to outputs driven low.
//
//   Pin function assignments that can vary per implementation are defined by
//   constants named
//
//     name_IN_PIN
//     name_OUT_PIN
//
//   in the board configuration section earlier in this file.  These constants
//   are the pin names ("RA1", "RB5", etc) to use for that function.  Such pins
//   will be defined /INBIT or /OUTBIT, named NAME, and set to the indicated
//   pin.  It is an error if multiple functions are specified for the same pin,
//   or a pin that has a fixed function assigned (above).  An error will also be
//   flagged when a xxx_IN_PIN or xxx_OUT_PIN constant exists to an unavailable
//   or non-existant pin.
//

//   Subroutine AssignPin port bit
//
//   If bit BIT within port PORT has not been assigned yet, then assign it.  It
//   is assigned according to a name_IN_PIN or name_OUT_PIN constant, if it
//   exists.  Otherwise, the pin is named the standard pin name ("RA1", "RB5",
//   etc) and set to an output initialized to low.
//
//   PORT must be the single port name letter, and BIT the 0-N number of the bit
//   within that port.
//
/subroutine AssignPin
  /var local port string = [ucase [qstr [arg 1]]] //upper case port name letter
  /var local bit integer = [vnl [arg 2]] //0-N bit number within the port
  /var local pdata string //name of Portdata_xx constant for this pin

  /set pdata [str "Portdata_" [lcase port] bit] //make Portdata_xx const name
  /if [exist pdata] then //this port already defined ?
    /return
    /endif
  //
  //   Look for name_IN_PIN or name_OUT_PIN constant for this pin.
  //
  /loop symbols syq const
    /var local sy string //bare symbol name
    /var local l integer //string length
    /var local valid bool
    /var local name string //our assigned pin name
    /var local out bool //output pin, not input pin

    /if [<> [sym syq dtype] "STRING"] then //not STRING data type ?
      /repeat
      /endif
    /set sy [sym syq name] //get bare symbol name
    /set l [slen sy] //length of bare symbol name
    /if [< l 8] then //too short for even x_IN_PIN ?
      /repeat
      /endif

    /set valid false
    /block
      /if [= [substr [- l 6] l sy] "_in_pin"] then //is xxx_IN_PIN ?
        /set name [substr 1 [- l 7] sy] //get assigned pin name
        /set valid true
        /set out false //indicate input pin
        /quit
        /endif
      /if [< l 9] then //too short for x_OUT_PIN ?
        /quit
        /endif
      /if [= [substr [- l 7] l sy] "_out_pin"] then //is xxx_OUT_PIN ?
        /set name [substr 1 [- l 8] sy] //get assigned pin name
        /set valid true
        /set out true //indicate output pin
        /quit
        /endif
      /endblock
    /if [not valid] then
      /repeat
      /endif
    //
    //   This is a name_IN_PIN or name_OUT_PIN constant.  NAME is name to
    //   assign to the pin, and OUT indicates the direction.
    //
    /call pinname_parse [chars syq] //set PINNAME_PORT, PINNAME_BIT
    /if [and [= pinname_port port] [= pinname_bit bit]] then //matches this pin ?
      /if out
        /then
          /outbit [chars name] port[chars [lcase port]] [v bit]
        /else
          /inbit [chars name] port[chars [lcase port]] [v bit]
        /endif
      /return
      /endif
    /endloop
  //
  //   No name_IN_PIN or name_OUT_PIN constant exists for this pin.  Set default
  //   assignment for this pin.
  //
  /outbit r[chars [lcase port]][v bit] port[chars [lcase port]] [v bit]
  /endsub

/call AssignPin A 0
/call AssignPin A 1
/call AssignPin A 2
/call AssignPin A 3
/call AssignPin A 4
/call AssignPin A 5

/call AssignPin B 0
/call AssignPin B 1
/call AssignPin B 2
/call AssignPin B 3
/call AssignPin B 4
/call AssignPin B 5
/call AssignPin B 6
/call AssignPin B 7

/call AssignPin C 0
/call AssignPin C 1
/call AssignPin C 2
/call AssignPin C 6
/call AssignPin C 7

//   Check for any xxx_IN_PIN or xxx_OUT_PIN constants that did not result in
//   the associated pin assignment.  This can be because the pin already had a
//   fixed function assigned, attempt to assign multiple functions to the same
//   pin, or attempt to assign a non-existing or invalid pin.
//
/var new err bool = false //init to no errors encountered

/loop symbols syq const
  /var local sy string //bare symbol name
  /var local l integer //string length
  /var local name string //our assigned pin name
  /var local out bool //output pin, not input pin
  /var local valid bool
  /var local pdata string //name of Portdata_xx constant
  /var local p integer //parse index
  /var local tk string //token parsed from string

  /if [<> [sym syq dtype] "STRING"] then //not STRING data type ?
    /repeat
    /endif
  /set sy [sym syq name] //get bare symbol name
  /set l [slen sy] //length of bare symbol name
  /if [< l 8] then //too short for even x_IN_PIN ?
    /repeat
    /endif

  /set valid false
  /block
    /if [= [substr [- l 6] l sy] "_in_pin"] then //is xxx_IN_PIN ?
      /set name [substr 1 [- l 7] sy] //get assigned pin name
      /set valid true
      /set out false //indicate input pin
      /quit
      /endif
    /if [< l 9] then //too short for x_OUT_PIN ?
      /quit
      /endif
    /if [= [substr [- l 7] l sy] "_out_pin"] then //is xxx_OUT_PIN ?
      /set name [substr 1 [- l 8] sy] //get assigned pin name
      /set valid true
      /set out true //indicate output pin
      /quit
      /endif
    /endblock
  /if [not valid] then
    /repeat
    /endif
  //
  //   This symbol is a pin assignment.  The following variables are set:
  //
  //     NAME  -  Name to assign to the pin.
  //
  //     OUT  -  TRUE for output pin, FALSE for input pin.
  //
  /call pinname_parse [chars syq] //set PINNAME_PORT, PINNAME_BIT
  /set pdata [str "Portdata_" [lcase pinname_port] pinname_bit]

  /if [not [exist [str pdata ":const"]]] then
    /show "  " [ucase sy] " specifies non-existant I/O pin " [chars syq] "."
    /set err true
    /repeat
    /endif

  /set p 1 //init parse index
  /call string_token [v [chars pdata]] p tk
  /if [<> [ucase name] [ucase tk]] then //pin didn't get this name ?
    /show "  " [ucase sy] " specifies duplicate assignment to " [chars syq] "."
    /set err true
    /repeat
    /endif
  /endloop

/if err then //found pin assignment errors ?
  /show
         error   Pin
         end
  /stop
  /endif
/del err

//   Show final pin assignments.
//
/if false then
  /call showval Portdata_a0
  /call showval Portdata_a1
  /call showval Portdata_a2
  /call showval Portdata_a3
  /call showval Portdata_a4
  /call showval Portdata_a5

  /call showval Portdata_b0
  /call showval Portdata_b1
  /call showval Portdata_b2
  /call showval Portdata_b3
  /call showval Portdata_b4
  /call showval Portdata_b5
  /call showval Portdata_b6
  /call showval Portdata_b7

  /call showval Portdata_c0
  /call showval Portdata_c1
  /call showval Portdata_c2
  /call showval Portdata_c6
  /call showval Portdata_c7
  /endif
